# java基础第一阶段

[TOC]



## 1.转义符

####  	\t   ： 制表符   实现对齐功能



#### 	\n :    换行符

#### 	

#### 	\  ： 

```
一个\ 可以转义 \   和 “  ” 。意思就是\后面 加上一个\ 之后 => \\  输出 一个\  加上一个"后=>    \"   输出   " .
```



```java
System.out.println("我说 :  \" 你好像一个 斜杠 \\  \"   ");
```





#### 一个回车 \r





## 2.Dos命令(常用

+ 查看当前目录有什么内容      dir      
+ 切换位置目录  cd          cd/D    
+ 返回到上级目录    cd..
+ 切换到根目录  cd \
+ 查看当前目录下的所有子级目录  tree
+ 清屏  cls
+ 退出Dos  exit
+ 



## 3.变量

 **变量的定义**

```
int age=18;
double score=99.99;
char sex='男';
String name="yn ";
```



+ 整数类型  byte[1]  short[2]  int[4] long[8]
+ 浮点数类型 float[4] double[8]
+ 字符型 char[2]
+ 布尔型 boolean[1]

#### 3.1整形类型

+  java各个整数类型有固定的额范围和字节长度 不受具体OS[操作系统影响以保证java程序的可移植性
+ java的整型常量 默认为int型 声明long型常量后面必须加 l 或者L
+ java程序中常量声明为int型 除非不足以表达大数才用long
+ bit 计算机中最小的存储单位 byte;计算机中基本存储单元  1byte=8bit
+  



#### 3.2 浮点类型

+ **单精度 float  4字节**

+ **双精度 double 8字节**

  **关于浮点数在机器中存放形式   浮点数= 符号位 +指数位+ 尾数位**

  **尾数部分可能丢失 造成精度损失（小数都是近似值）**

注意点：

 	+ 1.与整数类型相似 java类型也有固定的范围和字段长度  不受os影响
 	+ java的浮点型常量默认为double型 声明float后面 要加 f  或者 F
 	+ 十进制数形式  如 5.12  512.0f   .512
 	+ 小数做除法时 得到的是一个近似值
 	+ 



#### 3.3 字符类型

+ 1.字符常量是用单引号   ‘   ’  的 cahr a1=‘a’；

+ 2.java中还允许使用转义字符 ‘\’ 来将其 后的字符转变为特殊字符型字符型常量 

  cahr a2=‘\n’;

+ java中char的本质是一个整数 在输出时 是unicode码对应的字符

+ char字符可以运算 相当于一个整数  因为它都有对应的Unicode码



#### 3.4 String类型

+ 基本数据类型转String类型  将基本数据类型+“ ”即可
+ 将Sring转基本数据类型 需要用String中的方法
+ 



## 4.关系运算符

加减乘除  

==    !=   >=  <=  

+ 逻辑运算符  
+ +   短路与 &&  短路||  取反！
  + 逻辑与 &   逻辑或|  逻辑异或^ 
  + 



#### 三元运算符

+  条件表达式 ？ 表达式1：表达式2
+ + 结果为true 返回表达式1
  + 结果为true 返回表达式2



### 5.键盘输入语句

+  导入所需要的包  Scanner 文本扫描器
+ 创建该对象
+ 调用里面的功能

```java
public static void main(String[] args) {
    Scanner sc=new Scanner(System.in);

    int a=sc.nextInt();

    System.out.println(a);
}
```





## 6.数组

+ 数组 是引用类型
+ 可以存放 多个 同一类型的数据 数组也是一种数据类型   --- 数组就是一组数据
+ 

```java
//定义一个数组
//表示为double类型的额数组
double[] array1 = {3,5,1,3.3,2,23};
```



+ **增强for循环  for（数据类型 变量 ： 需要读取的数组）{  }**



+ #### 6.1**数组的初始化**

+ + **动态初始化**
  + +  **数据类型 数组名[ ] =new 数据类型[大小]**
    + **数据类型[ ] 数组名 =new 数据类型[大小]**
    + **例： int a[]=new int [5];        ==   int[] a=new int[5];**
    + **方式2** 
    + **先声明数组 再 分配空间**
    + **int a[]  或者 int[] a**
    + **再    a=new int[10];**
    + **第三种方式静态初始化**
    + **数组类型 数组名[] ={元素1，元素2，，，，，}**
    + **等效于 int a[] =new int [x];**

+ **注意事项**
+ + **一个数组里面必须是相同类型  可以满足自动类型转换**
  + **数组创建后没有赋值 有初始值**
  + +  **int ,short,byte long 为  0**
    + **float double 为 0.0**
    + **char 为  \u0000**
    + **boolean为 false**
    + **String为 null**
  + 

+ 数组拷贝  不能直接= 来赋值值数组  会指向同一个地址

```java
int[] a={1,2,3};
int[] b=new int[a.length];
for (int i = 0; i <a.length ; i++) {
    b[i] = a[i];
}
```

或者

```
int[] a={1,2,3,4,5,6,7,8};

int[] b=a.clone();
```

### 6.2 数组的添加 扩容

+ 

```java
        // 扩容   静态数组扩容  重新写一个数组
        int[] a1={1,2,3};
//
        int[] a2=new int[4];
        for(int i=0; i<a1.length; i++){
            a2[i]=a1[i];
        }
        a2[a2.length-1]=4;

        for (int i:a2       ) {
            System.out.println(i);
        }
```





### 6.3 二维数组

```java
int[][] a=new int[4][6];
```

+ 和一维数组差不多
+ 





## 7.类和对象（重点）

+ ### 7.1对象在内存中的布局形式

+ 

![image-20221113154427038](C:\Users\yn\AppData\Roaming\Typora\typora-user-images\image-20221113154427038.png)

+ + **字符串放在方法区**   堆内存中存放字符串的地址  ****
  + 常量 **直接放在堆中**

+ 注意
+ + 属性的定义类型可以为任意类型 包含基本类型或引用类型
  + 属性如果不赋值 有默认的值  规则和数组一样



![image-20221113160113430](C:\Users\yn\AppData\Roaming\Typora\typora-user-images\image-20221113160113430.png)

### 7.2 java对象创建流程

```java
Person p =new Person();
p.name="jack";
p.age=18;
```



+ + 1.先加载Person类信息（属性和方法信息，只会加载一次）
  + 2.在堆中分配空间，进行默认初始化（看规则），
  + 3.把地址赋值p  p就指向对象
  + 4.进行指定初始化 比如p.name=“jack”
  + 
  + **当给对象赋值为null时 会在栈区的地址边空**
  + ![image-20221113161229681](C:\Users\yn\AppData\Roaming\Typora\typora-user-images\image-20221113161229681.png)
  + 

  

### 7.3 对象方法

```java
public void speak(){
    System.out.println(this.name+"喵喵叫");
}
```

+  访问权限  返回值 方法名字（参数1.。。。。）{
  }

+ 对象方法调用机制
+ + 

### 7.4方法的定义

+  访问修饰符  返回值 方法名字（参数1.。。。。）{

  return 返回值；}

+ + 访问修饰符；
  + + public protected 默认  private

  + 返回类型：
  + + 一个方法最多有一个返回值
    + 返回类型也可以可以为任意类型，包含基本类型或引用类型
    + 而且要求返回值类型必须和return 的值类型一致或者兼容
    + 如果方法是void 则方法体中可以没有return语句或者只写 return；
    + 方法遵循驼峰命名法
  + 形参列表 
  + + 一个方法可以有0个参数 也可以有多个参数 中间用 ，逗号隔开
    + 参数类型可以为任意类型包含基本类型和引用类型
    + 调用带参的方法时候一定对应参数列表传入相同或兼容的类型的参数 个数 顺序必须一致
  + 方法体：
  + + 里面的方法不能嵌套定义，方法里面不能再定义方法
  + 方法调用；
  + + 同一个类的方法可以直接调用

### 7.5方法传参机制

+ 







### 7.6 对象的克隆

 





### 7.7递归

+ 方法自己调用自己
+ ![image-20221114162648043](C:\Users\yn\AppData\Roaming\Typora\typora-user-images\image-20221114162648043.png)



每次调用自己会创建一个新栈，直到到约束条件  ，当达到约束条件的那个执行完后 那个栈就会消失。并且会返回之前的栈 ，并执行命令  然后再消失，直到运行完。

+ 1.执行一个方法时，就创建了一个新的受保护的独立空间（栈空间）

+ 2.方法的局部变量是独立的，不会相互影响，比如n变量

+ 3.如果方法中使用的是引用变量（数组，对象） 就会共享该引用类型的数据

+ 4.递归必须向退出的条件逼近 否则会无限递归 出现StackOverflowError 栈溢出

+ 5.当一个方法执行完毕，或者遇到return 就会返回 遵循谁调用 就将结果返回给谁 同时方法执行完毕或者返回时该方法也就执行完毕。

  



### 8.方法重载

+ java中允许同一个 类中 多个同名方法的存在 但是要求 形参列表不一样
+ 方法名要一样
+ 形参列表；必须不同（形参类型或个数或顺序，至少有一样不同，参数名无要求
+ 返回类型无要求 
+ + 重载好处
  + + 减轻了起名的麻烦
    + 减轻了记名的麻烦

#### 8.1 可变参数

+ java中允许将同一个 多个同名功能但参数不同的方法 封装成一个方法。就可以通过可变参数实现

+ 访问修饰符 返回类型 方法名（数据类型… 形参名）{ }

+ 接收的参数可以当做数组来使用 ，数组名为形参名，传入的参数为数组里面的数

+ + 注意
  + + 可变参数 可以为0或任意多个
    + 可变参数的实参可以为数组
    + 可变参数的本质就是数组
    + 可变参数可以和普通类型的参数一起 ，但是必须放在最后面
    + 一个形参列表中只能出现一个可变参数

  

### 9.作用域

+ 1.在java中 主要的变量就是属性（成员变量）和局部变量
+ 2.局部变量一般是指在成员方法中定义的变量。
+ 3.全局变量：也就是属性，作用域为整个类体

​			局部变量：也就是除了属性之外的其他变量 作用域为定义它的代码块

+ 全局变量可以不赋值，直接使用，因为有默认值 局部变量必须赋值后，才能使用，因为没有默认值。
+ 作用域范围不同：可以被本类使用，或者其他类使用（通过对象调用）
+ 局部变量： 只能在本类中对应的方法中使用
+  修饰符不同
+ + 全局变量/属性可以加修饰符
  + 局部变量不可以加修饰符



### 10.构造方法/构造器

+ 构造方法又叫构造器 是类的一种特殊方法，他的 主要作用是完成对 新对象的初始化    
+ + 特点
  + + 方法名和类名相同
    + 没有返回值
    + 在创建对象，系统会自动的调用该类的构造器完成对象的初始化
+  有无参构造和有参构造
+ ![image-20221114232612633](C:\Users\yn\AppData\Roaming\Typora\typora-user-images\image-20221114232612633.png)

+ + 注意：
  + + 一个类可以定义多个不同构造器，即构造器重载
    + 构造器名和类名相同
    + 构造器没有返回值
    + 构造器是完成对象的初始化，并不是创建对象
    + 在创建对象时，系统自动的调用该类的方法
    + 如果没有定义构造器，系统会给类自动给类生成一个默认无参构造方法
    + 





### 11.枚举和注解

+ 1.不需要提供set方法 因为枚举对象值通常为只读
+ 2. 对枚举对象、属性 使用final+static 共同修饰 实现底层优化
  3. 枚举对象名通常使用全部大写 常量的命名规范
  4. 枚举对象根据需要 也可以有对个属性
  5. 构造器需要私有化

#### 使用enum关键字实现枚举类

+ 1.eunm代替class
+ 2.定义常量是  ：   SPRING(“春天”,“温暖”)；
+ 3.多个常量中间用逗号隔开
+ 4，将定义的常量对象写在最前面





#### 注解 Annotation

jdk内置的基本注解

+  1.@Overrride： 限定某个方法 是重写父类方法，该注解只能用于方法
+ 2.@Deprecated： 用于表示某个程序元素 类，方法已经过时了
+ 3.@SuppressWarnings： 抑制编译器警告





@Override

```java
class Father{
    public void fly(){
        System.out.println("father can fly");
    }
}
class Son extends Father{
@Override
    public void fly(){
    System.out.println("son can fly");
}

}
```

+ 1. @Override放在方法fly上时表示子类的fly方法重写了父类的fly
  2. 如果这里没有写@Override 还是重写了父类
  3. 如果写了@Override 注解 编译器就会去检查该方法算法自动重写了父类的方法 如果重写了则编译通过如果没有构成重写则编译器错误

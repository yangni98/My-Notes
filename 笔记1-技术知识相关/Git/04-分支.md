1.1 服务器运行模式
------------

   从右向左看

   用户在生产分支上进行使用，程序员在开发分支上进行开发

![](./images/8d0de43cb6d64674807bf63da4408402.png)

1.2  分支概念
---------

   在版本控制过程中，同时推进多个任务，我们就可以创建每个任务单独的分支。使用分支意味着程序员可以把自己的工作从开发主线上分离开，开发自己分支的时候，不会影响主线分支的运行，对初学者来说，分支可以简单的理解为副本，一个分支就是一个单独的副本**（分支底层其实也是指针的引用）**

比如下图来说，

    在master这个主线上运行，运行的同时要增加功能，那我们就可以把master赋值一份出来，在复制的地方进行开发，在开发完功能后就可以更新版本正常使用
    
    当我们引入新功能有bug，就可以从master分支再引一个分支hot-fix(热修分支)，对代码进行修改，修改后再合并到master

![](./images/b4ffef53cc684769ac3b0459e9a9c1bc.png)

 1.3 分支的好处
----------

 同时并行推进多个功能开发，提高效率

  各个分支在开发过程中，如果一个分支开发失败，不会对其他分支有任何影响。失败的分支删除重新开始即可。

 2.1 分支操作
---------

![](./images/eb79cef199f74c2abb11b3b275b9963c.png)

**2.2 查看当前分支**
--------------

```null
git branch -v

```

目前我们只有一个分支

![](./images/f4754bc580fe494bbcc9a96ba0f347fa.png)

2.3 创建分支
--------

```null
git branch 分支名
```

![](./images/42e3b33933bb4d37b1a4374bedadfaa1.png)

再次查看分支，发现确实多了一个

![](./images/bf87b2da5c9a49659d19ff90d8f68e2e.png)

2.4 切换分支
--------

### 2.4.1 切换分支

 我们可以看一下下图最后一行末尾的蓝字还是“master”，说明还是在master分支上面的

![](./images/e5bc0c32691b46e08f9b7d9395d6726b.png)

```null
git checkout  分支名
```

![](./images/98fcf8dd37154e5a89f3e3da5424b7f7.png)

 我们发现git后面的显示确实是从“master”变成了“hot-fix”

我们再查看一下分支，也确实改变了

![](./images/dab12912d842493c942e873b16c9c2a1.png)

### 2.4.2  修改代码并提交（完整过程）

![](./images/a05a7e10b1674c9db28c9a4023d53843.png)

  修改成下面的代码

![](./images/bcf450982b7046168b8c938e3dfd4eb2.png)

**我们可以查一下本地库状态**

 ![](./images/6c8fd6b2eebd47718f03ca9e5395222a.png)

**添加到本地库**

![](./images/b25b1f550f244823af8d21844fcd2120.png)

**提交到本地库**

![](./images/2fdecd1b0cc54b9ebeaca5109312488d.png)

**再次查看文件**

![](./images/58a78e4485d84e8999aa4820147e90e3.png)

**查看提交版本**

![](./images/de3225da902242b6ae83ee000d0837d4.png)

  先将分支切换为master分支然后再合并

![](./images/074c44e999674e6eb12d3fe6661a56d3.png)

然后我们查看一下代码，依然是原来的模样，因为当前指针又回来了，我们也没有合并

![](./images/211215e75609402b8ea7e106e48c545a.png)

**下面演示也下合并**

**命令：** 

```null
git merge 分支名
```

**把指定的分支合并到当前分支上**

  3.1 正常合并
----------

下面这段代码的含义就是将**“hot-fix”分支合并到“master”分支上**

![](./images/699bb19c92ee42f7936585775bc46ce7.png)

**合并成功，一个文件被修改，两个删除，两行增加**

**查看代码**

![](./images/ad9c2e8054f247d9afe7dbdc1b2d46f8.png)

**上面是正常的合并**

  3.2 冲突合并（企业常见）
----------------

  产生原因：合并分支时，两个分支在**同一个文件的同一个位置有两套完全不同的修改**，Git无法替我们决定使用哪一个，必需人为决定新代码内容

### **3.2.1 演示冲突情况（错误情况）：** 

    **先修改一下master分支**

![](./images/f205cbd962a24f1daaff9d0d0ce4bcd5.png)

**添加暂存区、提交本地库**

![](./images/06741e56d2d04d91b0cef7b72e2ec9ba.png)



**再修改一下hot-fix分支**

![](./images/b65710d1af044082809382f9bbc25caf.png)

![](./images/9e8fc74b312d425da25dd1d8c71cb972.png)


![](./images/d9bd662a70824166800e9017bb7fe577.png)

**切换回master开始操作**

![](./images/f38a0d5ff6a541a3805f3d49e90ff674.png)

**合并**

**类似下面的这种提示**![](./images/ef442be1d4ee4191943809eef9756a7d.png)

**查看本地库状态**

![](./images/c3f9605389b646aebc269718fcb40712.png)

就告诉我们了，hello.txt是没有合并成功的，两个分支都对他做了修改了

**此时就不能自动合并了，就需要我们手动合并代码**  


###  3.2.2 手动修改

**此时我们手动打开文件看一下，冲突的地方已经给我们标出来了**

**通过<<<<<   =====  >>>>\> 这种特殊符号标记出来冲突**

**<<<****HEAD 表示当前分支**

**在HEAD与====之间是当前分支的代码**

**在====与>>>>之间是我们要合并的代码**

**明显这两部分都做了修改，所以Git蒙蔽了**

![](./images/00ab7cf1c98a46f6aa9d5c65e59e873e.png)

**如何手动合并？**

   **想要把保存的留下来就可以了，手动删，把特殊符号也删掉，记得保存**

![](./images/136b4a48fa764808b3601d5b7ea0eeae.png)

此时我们应该把我们**修改之后的文件放到暂存区、提交本地库（这个时候提交不能带文件名）**

![](./images/82e75b29623041da829d9b8382b33d5c.png)

**完美查看文件**

![](./images/52a56787a3844dada86a8df84b5ac324.png)

###    3.2.3 底层仍是指针

![](./images/53d4a7fbc3ab40c6859d827d817b6724.png)